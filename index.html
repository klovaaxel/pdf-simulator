<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <title>PDF-Like Page Demo</title>
        <meta name="viewport" content="width=device-width,initial-scale=1" />
        <style>
            /* ====== GLOBAL RESETS ====== */
            * {
                box-sizing: border-box;
            }
            html,
            body {
                margin: 0;
                padding: 0;
            }
            body {
                font-family: "Times New Roman", Times, serif;
                line-height: 1.25;
                background: #ececec;
                color: #111;
                counter-reset: pageNumber;
            }

            /* ==== PAGE CONFIG (A4) ==== */
            :root {
                --page-width: 210mm;
                --page-height: 297mm;
                --page-margin-top: 20mm;
                --page-margin-right: 20mm;
                --page-margin-bottom: 25mm; /* extra for footer */
                --page-margin-left: 20mm;
                --printable-height: calc(var(--page-height) - var(--page-margin-top) - var(--page-margin-bottom));
            }

            @page {
                size: A4; /* Could switch to letter: 8.5in 11in */
                margin: 20mm 20mm 25mm 20mm; /* MUST mirror CSS vars for print fidelity */
            }

            /* Screen visualization of pages */
            .page {
                position: relative;
                width: var(--page-width);
                height: var(--page-height);
                padding: var(--page-margin-top) var(--page-margin-right) var(--page-margin-bottom)
                    var(--page-margin-left);
                background: #fff;
                margin: 10px auto; /* spacing between artificial pages on screen */
                box-shadow: 0 4px 16px rgba(0, 0, 0, 0.25);
                overflow: hidden; /* we control pagination, no accidental spill */
                display: flex;
                flex-direction: column;
            }

            .page {
                counter-increment: pageNumber;
            }

            .page-header {
                font-size: 14px;
                font-weight: 600;
                letter-spacing: 0.5px;
                margin-bottom: 6mm;
                border-bottom: 1px solid #444;
                padding-bottom: 2mm;
            }

            .page-footer {
                position: absolute;
                left: var(--page-margin-left);
                right: var(--page-margin-right);
                bottom: 8mm;
                font-size: 12px;
                display: flex;
                justify-content: space-between;
                align-items: center;
                color: #333;
                border-top: 1px solid #888;
                padding-top: 2mm;
            }

            .page-footer .page-number::after {
                content: "Page " counter(pageNumber);
            }

            /* The vertical space available for flowing dynamic content */
            .page-content {
                flex: 1 1 auto;
                /* Create a new block formatting context so measuring height is predictable */
                overflow: hidden;
                display: block;
                position: relative;
            }

            h1,
            h2,
            h3 {
                font-family: Georgia, serif;
                font-weight: 700;
                margin: 0 0 4mm;
                line-height: 1.15;
            }
            h1 {
                font-size: 22pt;
            }
            h2 {
                font-size: 16pt;
                margin-top: 6mm;
            }
            h3 {
                font-size: 13pt;
                margin-top: 5mm;
            }
            p {
                margin: 0 0 4mm;
                text-align: justify;
                hyphens: auto;
            }
            ul,
            ol {
                margin: 0 0 4mm 6mm;
            }

            /* Utility classes for controlling breaks when you DO have some control */
            .avoid-break {
                break-inside: avoid;
                page-break-inside: avoid;
            }
            .force-break-before {
                page-break-before: always;
                break-before: page;
            }
            .force-break-after {
                page-break-after: always;
                break-after: page;
            }

            /* Table styling example */
            table {
                width: 100%;
                border-collapse: collapse;
                margin: 0 0 4mm;
                font-size: 11pt;
            }
            th,
            td {
                border: 1px solid #444;
                padding: 2mm 3mm;
                vertical-align: top;
            }
            thead {
                background: #f2f2f2;
            }
            tr.avoid-break {
                break-inside: avoid;
            }

            /* Print adjustments (remove screen chrome, ensure continuous pages) */
            @media print {
                body {
                    background: #fff;
                }
                .page {
                    margin: 0 auto;
                    box-shadow: none;
                    page-break-after: always;
                }
                .page:last-child {
                    page-break-after: auto;
                }
                /* Ensure colors (browsers may still require user setting 'Print Backgrounds') */
                .page-header {
                    -webkit-print-color-adjust: exact;
                    print-color-adjust: exact;
                }
            }

            /* Optional: Visual debug overlay for page-content height (toggle by adding .debug class to body) */
            body.debug .page-content::after {
                content: attr(data-height-used) "/" attr(data-height-limit) "px";
                position: absolute;
                right: 2mm;
                top: 2mm;
                font: 10px monospace;
                background: rgba(255, 255, 0, 0.6);
                padding: 2px 4px;
            }
        </style>
    </head>
    <body>
        <!-- Container whose children (sections) will be paginated dynamically -->
        <div id="dynamic-sections" style="display: none">
            <h1>PDF-like Page Layout Demo</h1>
            <p>
                This demonstration shows how to make an HTML document render and print with stable pagination closely
                matching a PDF: fixed physical dimensions (A4), consistent margins, headers/footers, page numbers, and
                graceful page-breaking of dynamic content whose exact length you may not control.
            </p>
            <p>
                The approach combines CSS (physical units, @page, counters, page-break utilities) with a light
                JavaScript pagination pass that measures overflow and migrates overflowing semantic blocks to subsequent
                pages. This keeps the DOM readable and avoids manually slicing text mid-paragraph.
            </p>

            <h2>Key Techniques</h2>
            <ul>
                <li><strong>Physical units:</strong> All core dimensions use millimeters (A4 = 210mm Ã— 297mm).</li>
                <li><strong>@page rule:</strong> Aligns print margins with on-screen simulation.</li>
                <li>
                    <strong>Page shell:</strong> Each logical page is a <code>div.page</code> with header, footer, and a
                    measured <code>.page-content</code> region.
                </li>
                <li><strong>CSS counters:</strong> Increment page numbers automatically.</li>
                <li>
                    <strong>Overflow algorithm:</strong> JS places whole sections; if adding a section causes overflow
                    beyond printable height, it moves it to a new page.
                </li>
                <li>
                    <strong>Utilities:</strong> Classes like <code>.avoid-break</code> offer hints when you can annotate
                    source blocks.
                </li>
            </ul>

            <h2>Dynamic Content Considerations</h2>
            <p>
                Because content length is unpredictable, purely declarative CSS page breaks can produce orphaned
                headings or split tables. The JavaScript layer inspects cumulative height after appending each section
                and triggers a new page before the overflow becomes visible.
            </p>
            <p>
                For extremely long single elements (e.g., a giant table) exceeding one page alone, a more advanced
                splitter would be needed (row-by-row migration or canvas pagination). This demo keeps logic
                intentionally lightweight.
            </p>

            <h2>Sample Data Table</h2>
            <p class="avoid-break">
                This table demonstrates repeating structured data. Rows are split across pages as needed.
            </p>
            <table>
                <thead>
                    <tr class="avoid-break">
                        <th>#</th>
                        <th>Item</th>
                        <th>Description</th>
                        <th>Qty</th>
                        <th>Price</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>1</td>
                        <td>Item 1</td>
                        <td>Description for item 1</td>
                        <td>10</td>
                        <td>$100</td>
                    </tr>
                    <tr>
                        <td>2</td>
                        <td>Item 2</td>
                        <td>Description for item 2</td>
                        <td>5</td>
                        <td>$50</td>
                    </tr>
                    <tr>
                        <td>3</td>
                        <td>Item 3</td>
                        <td>Description for item 3</td>
                        <td>20</td>
                        <td>$200</td>
                    </tr>
                    <tr>
                        <td>4</td>
                        <td>Item 4</td>
                        <td>Description for item 4</td>
                        <td>15</td>
                        <td>$150</td>
                    </tr>
                    <tr>
                        <td>5</td>
                        <td>Item 5</td>
                        <td>Description for item 5</td>
                        <td>8</td>
                        <td>$80</td>
                    </tr>
                    <tr>
                        <td>6</td>
                        <td>Item 6</td>
                        <td>Description for item 6</td>
                        <td>12</td>
                        <td>$120</td>
                    </tr>
                </tbody>
            </table>

            <h2>Forcing a Manual Break</h2>
            <p>
                You can force a manual page break by adding the class <code>force-break-before</code> or
                <code>force-break-after</code> to a block. After this paragraph, there is a forced break before the next
                section.
            </p>

            <div class="force-break-after"></div>

            <h2>Limitations & Notes</h2>
            <ul>
                <li>Browser print engines differ slightly; millimeter accuracy is approximate.</li>
                <li>User print settings (margins, scale, background graphics) must remain default for fidelity.</li>
                <li>
                    Running headers/footers (CSS Paged Media Module Level 3) have partial support; we emulate per-page
                    duplicates.
                </li>
                <li>
                    Long unbreakable content (huge images, wide tables) may overflow; consider pre-processing or more
                    granular splitting.
                </li>
                <li>
                    Editing content directly in the browser may affect measurements and page overflow; Re-evaluate
                    layout and styles as needed. (we first need to turn the paginated content back to non paginated to
                    then reapply pagination, and this can't be done when the user is actively editing as that would
                    remove focus from the editable element)
                </li>
            </ul>

            <h2>Conclusion</h2>
            <p>
                This approach yields a maintainable, semantic HTML structure that prints like a PDF while remaining
                accessible and indexable. Adjust variables, refine the pagination algorithm, and incorporate
                content-specific rules to reach near-PDF parity.
            </p>
        </div>
        <!-- Pagination target root -->
        <div id="pages-root"></div>
        <script>
            (function () {
                console.debug("[pdf] loader start");

                // ===== State =====
                let BLOCK_COUNTER = 0;
                function nextBlockId() {
                    return "b" + ++BLOCK_COUNTER;
                }

                const LIVE = { enabled: false, observer: null, rebuilding: false, pending: false };

                // ===== Public API =====
                window.rebuildPDFView = rebuildPDFView;
                window.buildPDFViewHTML = buildPDFViewHTML;
                window.enableLivePagination = enableLivePagination;

                document.addEventListener("DOMContentLoaded", () => {
                    console.debug("[pdf] DOMContentLoaded");
                    rebuildPDFView();
                    enableLivePagination();
                });

                // ===== High-level Rebuild =====
                function rebuildPDFView(options = {}) {
                    const pagesRoot = document.getElementById("pages-root");
                    if (!pagesRoot) {
                        console.debug("[pdf] no #pages-root found");
                        return "";
                    }
                    console.debug("[pdf] rebuildPDFView start");
                    const html = buildPDFViewHTML(options);
                    pagesRoot.innerHTML = html;
                    console.debug("[pdf] rebuildPDFView injected pages:", pagesRoot.querySelectorAll(".page").length);
                    return html;
                }

                function buildPDFViewHTML(options = {}) {
                    const dynamicRoot = document.getElementById("dynamic-sections");
                    if (!dynamicRoot) {
                        console.debug("[pdf] no #dynamic-sections");
                        return "";
                    }

                    if (options.regenerate === true) {
                        console.debug("[pdf] (unused) regenerate flag seen");
                    }

                    const tempHost = document.createElement("div");
                    tempHost.style.cssText = "position:absolute;left:-9999px;top:0;visibility:hidden;";
                    document.body.appendChild(tempHost);
                    const { pages } = paginate(dynamicRoot, tempHost, options);
                    const html = pages.map((p) => p.outerHTML).join("");
                    document.body.removeChild(tempHost);
                    return html;
                }

                // ===== Pagination Core =====
                function paginate(sourceRoot, pagesRoot, options) {
                    pagesRoot.innerHTML = "";
                    const children = Array.from(sourceRoot.children);
                    const pages = [];
                    let currentPage = createEmptyPage(pagesRoot, options);
                    pages.push(currentPage);

                    let contentEl = currentPage.querySelector(".page-content");
                    let limit = getContentHeightLimit(currentPage); // dynamic measurement
                    const TOLERANCE = -24; // px of acceptable overflow before breaking (allows for small inaccuracies)
                    function dlog(...a) {
                        console.debug("[paginate]", ...a);
                    }
                    dlog("start, child count", children.length, "limit", limit);

                    function recalcLimit() {
                        limit = getContentHeightLimit(currentPage);
                        return limit;
                    }

                    for (let i = 0; i < children.length; i++) {
                        recalcLimit();
                        const original = children[i];
                        if (!original.dataset.blockId) original.dataset.blockId = nextBlockId();
                        const blockId = original.dataset.blockId;
                        const isTable = original.tagName === "TABLE";
                        const hasForceBefore = original.classList.contains("force-break-before");
                        const hasForceAfter = original.classList.contains("force-break-after");
                        const hasAvoidBreak = original.classList.contains("avoid-break");

                        if (hasForceBefore && contentEl.children.length > 0) {
                            dlog("force-break-before -> new page");
                            ({ contentEl } = newPage());
                            recalcLimit();
                        }

                        if (isTable) {
                            dlog(
                                "table candidate index",
                                i,
                                "rows",
                                original.tBodies[0]?.rows.length || 0,
                                "limit",
                                limit
                            );
                            const tableClone = original.cloneNode(true);
                            tableClone.dataset.blockId = blockId;
                            contentEl.appendChild(tableClone);
                            if (contentEl.scrollHeight - limit > TOLERANCE) {
                                dlog("table overflow -> split");
                                contentEl.removeChild(tableClone);
                                i = handleTableSplit(original, i, contentEl, limit, newPage, TOLERANCE, dlog);
                            }
                            if (hasForceAfter) {
                                dlog("force-break-after after table");
                                ({ contentEl } = newPage());
                                recalcLimit();
                            }
                            continue;
                        }

                        const clone = original.cloneNode(true);
                        clone.dataset.blockId = blockId;
                        contentEl.appendChild(clone);
                        recalcLimit();
                        if (contentEl.scrollHeight - limit > TOLERANCE) {
                            const elHeight = clone.getBoundingClientRect().height;
                            const freshLimit = getContentHeightLimit(currentPage);
                            const canFitFresh = elHeight < freshLimit - TOLERANCE;
                            if (hasAvoidBreak && canFitFresh && contentEl.children.length > 1) {
                                dlog("overflow, retry on fresh page (avoid-break)");
                                contentEl.removeChild(clone);
                                ({ contentEl } = newPage());
                                recalcLimit();
                                contentEl.appendChild(clone);
                            }
                        }
                        recalcLimit();
                        if (contentEl.scrollHeight - limit > TOLERANCE) {
                            if (!hasAvoidBreak) {
                                const elHeight2 = clone.getBoundingClientRect().height;
                                if (elHeight2 < limit - TOLERANCE && contentEl.children.length > 1) {
                                    dlog("overflow, move block to new page");
                                    contentEl.removeChild(clone);
                                    ({ contentEl } = newPage());
                                    recalcLimit();
                                    contentEl.appendChild(clone);
                                } else {
                                    dlog("very tall element allowed to spill");
                                }
                            }
                        }
                        if (hasForceAfter) {
                            dlog("force-break-after");
                            ({ contentEl } = newPage());
                            recalcLimit();
                        }
                    }

                    return { pages, contentLimitPx: limit };

                    function newPage() {
                        currentPage = createEmptyPage(pagesRoot, options);
                        pages.push(currentPage);
                        contentEl = currentPage.querySelector(".page-content");
                        limit = getContentHeightLimit(currentPage);
                        dlog("new page created, limit=", limit);
                        return { contentEl, limit };
                    }
                }

                function handleTableSplit(
                    originalTable,
                    currentIndex,
                    contentEl,
                    limit,
                    newPageFn,
                    tolerance,
                    dlog = () => {}
                ) {
                    const header = originalTable.tHead ? originalTable.tHead.cloneNode(true) : null;
                    const bodyRows = Array.from(originalTable.tBodies[0]?.rows || []);
                    if (!originalTable.dataset.blockId) originalTable.dataset.blockId = nextBlockId();
                    const originId = originalTable.dataset.blockId;
                    if (bodyRows.length === 0) {
                        dlog("empty body -> insert whole");
                        const single = originalTable.cloneNode(true);
                        single.dataset.blockId = originId;
                        contentEl.appendChild(single);
                        return currentIndex;
                    }
                    let rowPtr = 0;
                    while (rowPtr < bodyRows.length) {
                        let segTable = document.createElement("table");
                        segTable.setAttribute("data-split-table", "");
                        segTable.dataset.originTableId = originId;
                        if (header) segTable.appendChild(header.cloneNode(true));
                        const segBody = document.createElement("tbody");
                        segTable.appendChild(segBody);
                        contentEl.appendChild(segTable);

                        // If just adding the header already overflows and there is existing content, move to new page first
                        if (contentEl.scrollHeight - limit > tolerance && contentEl.children.length > 1) {
                            dlog("header alone overflow -> move segment to fresh page");
                            contentEl.removeChild(segTable);
                            ({ contentEl, limit } = newPageFn());
                            segTable = document.createElement("table");
                            segTable.setAttribute("data-split-table", "");
                            segTable.dataset.originTableId = originId;
                            if (header) segTable.appendChild(header.cloneNode(true));
                            const segBody2 = document.createElement("tbody");
                            segTable.appendChild(segBody2);
                            contentEl.appendChild(segTable);
                        }

                        let lastGoodCount = 0;
                        for (; rowPtr < bodyRows.length; rowPtr++) {
                            const testRow = bodyRows[rowPtr].cloneNode(true);
                            segTable.tBodies[0].appendChild(testRow);
                            if (contentEl.scrollHeight - limit > tolerance) {
                                // overflow after adding test row
                                segTable.tBodies[0].removeChild(testRow);
                                dlog("row overflow break segment at row", rowPtr);
                                break;
                            } else {
                                lastGoodCount++;
                            }
                        }

                        if (lastGoodCount === 0) {
                            // The next row could not fit at all on this page; move whole segment (header) to new page unless this page is empty of other segments
                            const pageHasOtherBlocks = contentEl.children.length > 1; // header-only segment counts as 1 currently
                            if (pageHasOtherBlocks) {
                                dlog("first row can't fit -> relocate segment to new page before forcing row");
                                contentEl.removeChild(segTable);
                                ({ contentEl, limit } = newPageFn());
                                // rebuild segTable on the fresh page
                                segTable = document.createElement("table");
                                segTable.setAttribute("data-split-table", "");
                                segTable.dataset.originTableId = originId;
                                if (header) segTable.appendChild(header.cloneNode(true));
                                const newBody = document.createElement("tbody");
                                segTable.appendChild(newBody);
                                contentEl.appendChild(segTable);
                            } else {
                                dlog("first row too tall even on fresh page -> allow spill");
                            }
                            // Force single row (may still overflow, acceptable spill policy for very tall row)
                            const forced = bodyRows[rowPtr].cloneNode(true);
                            segTable.tBodies[0].appendChild(forced);
                            rowPtr++;
                        }

                        // If more rows remain, start a new page for next segment
                        if (rowPtr < bodyRows.length) {
                            ({ contentEl, limit } = newPageFn());
                        }
                    }
                    return currentIndex;
                }

                // ===== Live Editing =====
                function enableLivePagination({ debounceMs = 400 } = {}) {
                    if (LIVE.enabled) {
                        console.debug("[live] already enabled");
                        return;
                    }
                    const pagesRoot = document.getElementById("pages-root");
                    const sourceRoot = document.getElementById("dynamic-sections");
                    if (!pagesRoot || !sourceRoot) {
                        console.debug("[live] missing roots");
                        return;
                    }
                    pagesRoot.setAttribute("contenteditable", "true");
                    const schedule = () => {
                        console.debug(
                            "[live] schedule invoked; rebuilding=",
                            LIVE.rebuilding,
                            "suppress=",
                            LIVE.suppressNext
                        );
                        if (LIVE.rebuilding) {
                            console.debug("[live] schedule skip: rebuilding in progress");
                            return;
                        }
                        if (LIVE.suppressNext) {
                            console.debug("[live] schedule skip: suppressNext flag");
                            return;
                        }
                        clearTimeout(LIVE.pending);
                        LIVE.pending = setTimeout(performReflow, debounceMs);
                    };
                    pagesRoot.addEventListener("input", schedule);
                    pagesRoot.addEventListener("paste", schedule);
                    pagesRoot.addEventListener("keydown", (e) => {
                        if (["Enter", "Backspace", "Delete"].includes(e.key)) schedule();
                    });
                    LIVE.observer = new MutationObserver((muts) => {
                        if (LIVE.rebuilding) return; // ignore our own rebuilds
                        schedule();
                    });
                    LIVE.observer.observe(pagesRoot, { childList: true, subtree: true, characterData: true });
                    LIVE.enabled = true;
                    LIVE.lastHash = null;
                    console.debug("[live] enabled");

                    function performReflow() {
                        if (LIVE.rebuilding) return;
                        LIVE.rebuilding = true;
                        console.debug("[live] performReflow start");
                        // Insert a lightweight marker at caret (more reliable than char offset when paragraphs split)
                        const markerPlaced = placeCaretMarker(pagesRoot);
                        // Fallback selection snapshot (legacy) in case marker fails
                        const selState = markerPlaced ? null : captureSelection(pagesRoot);
                        try {
                            if (LIVE.observer) LIVE.observer.disconnect();
                            flattenPagesBackIntoSource(pagesRoot, sourceRoot);
                            const html = buildPDFViewHTML();
                            // Ignore caret marker when computing hash so transient markers don't force rebuilds
                            const hashReady = html.replace(/<span[^>]*data-caret-marker="1"[^>]*><\/span>/g, "");
                            const newHash = hashString(hashReady);
                            if (newHash === LIVE.lastHash) {
                                console.debug("[live] no DOM diff (hash match) -> skip inject");
                                if (markerPlaced) {
                                    // We never injected new HTML, marker is still present in pagesRoot; just restore & remove
                                    restoreCaretMarker(pagesRoot);
                                } else {
                                    restoreSelection(pagesRoot, selState);
                                }
                            } else {
                                LIVE.lastHash = newHash;
                                pagesRoot.innerHTML = html;
                                console.debug("[live] injected new pages (hash updated)");
                                if (markerPlaced) {
                                    restoreCaretMarker(pagesRoot);
                                } else {
                                    restoreSelection(pagesRoot, selState);
                                }
                                pagesRoot.focus();
                            }
                            LIVE.suppressNext = true;
                            setTimeout(() => {
                                LIVE.suppressNext = false;
                            }, 0);
                        } finally {
                            if (LIVE.observer) {
                                LIVE.observer.observe(pagesRoot, {
                                    childList: true,
                                    subtree: true,
                                    characterData: true,
                                });
                            }
                            LIVE.rebuilding = false;
                            console.debug("[live] performReflow end");
                        }
                    }
                }

                // ===== Selection Preservation Utilities =====
                function placeCaretMarker(root) {
                    const sel = window.getSelection();
                    if (!sel || sel.rangeCount === 0) return false;
                    const range = sel.getRangeAt(0);
                    if (!root.contains(range.startContainer)) return false;
                    // Avoid duplicating markers
                    root.querySelectorAll("[data-caret-marker]")?.forEach((n) => n.remove());
                    const span = document.createElement("span");
                    span.setAttribute("data-caret-marker", "1");
                    span.style.cssText =
                        "display:inline-block;width:0;height:0;overflow:hidden;line-height:0;font-size:0;";
                    range.insertNode(span);
                    // Collapse after marker so typing continues in correct place pre-rebuild
                    range.setStartAfter(span);
                    range.collapse(true);
                    sel.removeAllRanges();
                    sel.addRange(range);
                    return true;
                }

                function restoreCaretMarker(root) {
                    const marker = root.querySelector("[data-caret-marker]");
                    if (!marker) return;
                    const sel = window.getSelection();
                    if (!sel) {
                        marker.remove();
                        return;
                    }
                    const range = document.createRange();
                    range.setStartAfter(marker);
                    range.collapse(true);
                    sel.removeAllRanges();
                    sel.addRange(range);
                    marker.remove();
                }

                function captureSelection(root) {
                    const sel = window.getSelection();
                    if (!sel || sel.rangeCount === 0) return null;
                    const range = sel.getRangeAt(0);
                    if (!root.contains(range.startContainer)) return null;
                    // Try normal block resolution first
                    let el =
                        range.startContainer.nodeType === 1 ? range.startContainer : range.startContainer.parentElement;
                    while (el && el !== root && !el.dataset.blockId && !el.dataset.originTableId) {
                        el = el.parentElement;
                    }
                    if (el && el !== root) {
                        const blockId = el.dataset.blockId || el.dataset.originTableId;
                        if (!blockId) return null;
                        // Compute character offset within that block
                        let charOffset = 0;
                        const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null);
                        let node;
                        while ((node = walker.nextNode())) {
                            if (node === range.startContainer) {
                                charOffset += range.startOffset;
                                break;
                            } else {
                                charOffset += node.textContent.length;
                            }
                        }
                        return { blockId, charOffset };
                    }
                    // Fallback: caret might be in a freshly created empty line (Enter) that has no blockId yet.
                    // Strategy: find preceding sibling with a blockId and mark position as AFTER that block.
                    const pageContent =
                        range.startContainer.parentElement &&
                        range.startContainer.parentElement.closest(".page-content");
                    if (!pageContent) return null;
                    // Determine a reference node inside pageContent to compare order
                    let refNode =
                        range.startContainer.nodeType === 1 ? range.startContainer : range.startContainer.parentElement;
                    if (!pageContent.contains(refNode)) return null;
                    // Ascend until direct child of pageContent (or pageContent itself if text directly under)
                    while (refNode && refNode.parentElement && refNode.parentElement !== pageContent) {
                        refNode = refNode.parentElement;
                    }
                    // Collect previous siblings looking for last with data-block-id
                    let prev = refNode;
                    while (prev && prev.previousSibling) {
                        prev = prev.previousSibling;
                        if (prev.nodeType === 1 && (prev.dataset.blockId || prev.dataset.originTableId)) {
                            const blockId = prev.dataset.blockId || prev.dataset.originTableId;
                            if (blockId) {
                                // Compute char length of that block for reference (end position)
                                let len = 0;
                                const walker = document.createTreeWalker(prev, NodeFilter.SHOW_TEXT, null);
                                let tn;
                                while ((tn = walker.nextNode())) len += tn.textContent.length;
                                return { blockId, charOffset: len, after: true };
                            }
                        }
                    }
                    return null;
                }

                function restoreSelection(root, state) {
                    if (!state) return;
                    const el =
                        root.querySelector('[data-block-id="' + state.blockId + '"]') ||
                        root.querySelector('[data-origin-table-id="' + state.blockId + '"]');
                    if (!el) return;
                    if (state.after) {
                        // We want caret at start of the next block if it exists; else end of current block.
                        const allBlocks = Array.from(root.querySelectorAll("[data-block-id]"));
                        const idx = allBlocks.indexOf(el);
                        let targetBlock = null;
                        if (idx !== -1 && idx + 1 < allBlocks.length) {
                            targetBlock = allBlocks[idx + 1];
                        }
                        if (!targetBlock) {
                            // place at end of el
                            let lastText = null;
                            const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null);
                            let tn;
                            while ((tn = walker.nextNode())) lastText = tn;
                            const sel = window.getSelection();
                            if (!sel) return;
                            const r = document.createRange();
                            if (lastText) {
                                r.setStart(lastText, lastText.textContent.length);
                            } else {
                                r.selectNodeContents(el);
                                r.collapse(false);
                            }
                            sel.removeAllRanges();
                            sel.addRange(r);
                            return;
                        } else {
                            // place at start of targetBlock
                            const sel = window.getSelection();
                            if (!sel) return;
                            const r = document.createRange();
                            // Find first text node
                            let firstText = null;
                            const walker2 = document.createTreeWalker(targetBlock, NodeFilter.SHOW_TEXT, null);
                            firstText = walker2.nextNode();
                            if (firstText) {
                                r.setStart(firstText, 0);
                            } else {
                                r.selectNodeContents(targetBlock);
                                r.collapse(true);
                            }
                            sel.removeAllRanges();
                            sel.addRange(r);
                            return;
                        }
                    }
                    // Original behavior
                    let remaining = state.charOffset;
                    const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null);
                    let node;
                    let targetNode = null;
                    let offset = 0;
                    while ((node = walker.nextNode())) {
                        const len = node.textContent.length;
                        if (remaining <= len) {
                            targetNode = node;
                            offset = remaining;
                            break;
                        }
                        remaining -= len;
                    }
                    if (!targetNode) {
                        targetNode = el;
                        offset = el.childNodes.length;
                        try {
                            const revWalker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT, null);
                            let lastText = null,
                                tn;
                            while ((tn = revWalker.nextNode())) lastText = tn;
                            if (lastText) {
                                targetNode = lastText;
                                offset = lastText.textContent.length;
                            }
                        } catch {}
                    }
                    const sel = window.getSelection();
                    if (!sel) return;
                    const r = document.createRange();
                    try {
                        r.setStart(targetNode, Math.min(offset, (targetNode.textContent || "").length || 0));
                    } catch (e) {
                        return;
                    }
                    r.collapse(true);
                    sel.removeAllRanges();
                    sel.addRange(r);
                }

                function hashString(str) {
                    let h = 0,
                        i = 0,
                        len = str.length;
                    if (!len) return h.toString();
                    // Simple 32-bit hash
                    for (; i < len; i++) {
                        h = (h << 5) - h + str.charCodeAt(i);
                        h |= 0;
                    }
                    return h.toString();
                }

                function flattenPagesBackIntoSource(pagesRoot, sourceRoot) {
                    console.debug("[flatten] start");
                    const pageContents = pagesRoot.querySelectorAll(".page-content");
                    const fragment = document.createDocumentFragment();
                    const tableBuckets = new Map();
                    const order = [];

                    pageContents.forEach((pc) => {
                        // Walk childNodes to preserve ordering of text nodes relative to elements
                        Array.from(pc.childNodes).forEach((node) => {
                            if (node.nodeType === 3) {
                                // text
                                if (!node.textContent.trim()) return; // ignore pure whitespace
                                const wrapper = document.createElement("p");
                                wrapper.textContent = node.textContent;
                                wrapper.dataset.blockId = nextBlockId();
                                order.push({ type: "block", id: wrapper.dataset.blockId, node: wrapper });
                                return;
                            }
                            if (node.nodeType !== 1) return; // element only
                            const child = node; // element
                            if (child.matches("[data-split-table]")) {
                                const originId = child.dataset.originTableId;
                                if (!tableBuckets.has(originId)) {
                                    tableBuckets.set(originId, { headerHTML: "", rows: [] });
                                    order.push({ type: "table", id: originId });
                                }
                                const bucket = tableBuckets.get(originId);
                                const thead = child.querySelector("thead");
                                if (thead && !bucket.headerHTML) bucket.headerHTML = thead.outerHTML;
                                child.querySelectorAll("tbody tr").forEach((r) => bucket.rows.push(r.cloneNode(true)));
                            } else if (child.tagName === "TABLE" && !child.hasAttribute("data-split-table")) {
                                const id = child.dataset.blockId || (child.dataset.blockId = nextBlockId());
                                order.push({ type: "single-table", id, node: child });
                            } else {
                                if (!child.dataset.blockId) child.dataset.blockId = nextBlockId();
                                order.push({ type: "block", id: child.dataset.blockId, node: child });
                            }
                        });
                    });

                    for (const entry of order) {
                        if (entry.type === "table") {
                            const bucket = tableBuckets.get(entry.id);
                            if (!bucket) continue;
                            const table = document.createElement("table");
                            table.dataset.blockId = entry.id;
                            if (bucket.headerHTML) table.insertAdjacentHTML("beforeend", bucket.headerHTML);
                            const tbody = document.createElement("tbody");
                            bucket.rows.forEach((r) => tbody.appendChild(r));
                            table.appendChild(tbody);
                            fragment.appendChild(table);
                        } else if (entry.type === "single-table") {
                            fragment.appendChild(entry.node.cloneNode(true));
                        } else if (entry.type === "block") {
                            fragment.appendChild(entry.node.cloneNode(true));
                        }
                    }
                    sourceRoot.innerHTML = "";
                    sourceRoot.appendChild(fragment);
                    console.debug("[flatten] rebuilt source children:", sourceRoot.children.length);
                }

                // === Utility page builders (was truncated previously) ===
                function createEmptyPage(pagesRoot, options) {
                    const page = document.createElement("div");
                    page.className = "page";
                    const headerText = options.headerText || "Sample Report Header";
                    const dateStr = (options.date instanceof Date ? options.date : new Date()).toLocaleDateString();
                    page.innerHTML = `
            <div class="page-header">${headerText}</div>
            <div class="page-content"></div>
            <div class="page-footer">
              <div class="page-number"></div>
              <div class="page-date">Generated: <span>${dateStr}</span></div>
            </div>`;
                    pagesRoot.appendChild(page);
                    return page;
                }

                function getContentHeightLimit(page) {
                    const content = page.querySelector(".page-content");
                    const footer = page.querySelector(".page-footer");
                    if (!content) return 0;
                    // If footer exists compute distance between top of content and top of footer as usable height
                    if (footer) {
                        const usable = footer.offsetTop - content.offsetTop;
                        // Fallback if something unexpected
                        if (usable > 0) return usable;
                    }
                    // Fallback to current content box height
                    return content.getBoundingClientRect().height;
                }

                console.debug("[pdf] script ready");
            })();
        </script>
    </body>
</html>
